# -*- coding: utf-8 -*-
"""RekomendasiSpotify.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1wIn6V4jaEWb7kHIVxptq-9ZSS8jBBQAf

# Rekomendasi Spotify
"""

from google.colab import drive
drive.mount('/content/drive')

import pandas as pd
import numpy as np
from matplotlib import pyplot as plt
from wordcloud import WordCloud
import seaborn as sns
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity
from sklearn.preprocessing import MinMaxScaler

df = pd.read_csv('/content/drive/MyDrive/spotify_dataset/dataset.csv')
df

"""## Data Understanding

### Informasi Statistik Dataset
"""

df.head()

df.info()

df = df.drop(df.columns[0], axis =1)

"""### Menangani Nilai Duplikat"""

print(f"jumlah nilai duplikat dalam data  : {df.duplicated().sum()}")

df = df.drop_duplicates()

print(f"jumlah nilai duplikat dalam data  : {df.duplicated().sum()}")

df.loc[df.track_id.duplicated()].sort_values(by= 'track_id')

df.loc[df['track_id'] == '1R0hxCA5R7z5TiaXBZR7Mf', ['track_id', 'artists', 'album_name', 'track_name', 'track_genre']]

combined_genres = {}

for _, row in df.iterrows():
    track_id = row['track_id']
    genre = row['track_genre']

    if track_id in combined_genres:
        combined_genres[track_id].append(genre)
    else:
        combined_genres[track_id] = [genre]

def get_combined_genres(row):
    track_id = row['track_id']
    if track_id in combined_genres:
        return combined_genres[track_id]
    else:
        return [row['track_genre']]

df['track_genre'] = df.apply(get_combined_genres, axis=1)

df

df['track_genre'] = df['track_genre'].apply(lambda x: ",".join(x))

print(f"jumlah nilai duplikat dalam data  : {df.duplicated().sum()}")

df = df.drop_duplicates()

df

df.loc[df['track_id'] == '1R0hxCA5R7z5TiaXBZR7Mf', ['track_id', 'artists', 'album_name', 'track_name', 'track_genre']]

df.isna().sum()

df = df.dropna(axis = 0)

df.isna().sum()

"""### Sampling"""

df = df.sample(35000)

"""### Univariate Analysis

#### Fitur Kategorikal
"""

df_categorical = df.select_dtypes(include= 'object')

df_categorical

genre = df_categorical['track_genre'].value_counts()
genre

genre = df_categorical['track_genre'].value_counts().head(25)
genre.plot(kind= 'barh')

genre = df_categorical['track_genre'].value_counts()[25:50]
# genre berjumlah 114
genre.plot(kind= 'barh')

genre = df_categorical['track_genre'].value_counts()[114:140]
# genre berjumlah 114
genre.plot(kind= 'barh')

text = ' '.join(df['artists'])
plt.figure(figsize=(15, 12))
wordcloud = WordCloud(background_color = 'black').generate(text)
plt.imshow(wordcloud)

df_categorical.loc[(df_categorical['artists'].str.contains("blackpink", case = False))]

text = ' '.join(df['track_name'])
plt.figure(figsize=(15, 12))
wordcloud = WordCloud(background_color = 'black').generate(text)
plt.imshow(wordcloud)

text = ' '.join(df['album_name'])
plt.figure(figsize=(15, 12))
wordcloud = WordCloud(background_color = 'black').generate(text)
plt.imshow(wordcloud)

"""#### Fitur Numerik"""

df_numerik = df.select_dtypes(include=['float64', 'int64'])

df_numerik

"""Penulis mengelompokan data popularity ke dalam rentang diskrit yang masing-masing terdiri dari lima poin. Jenis transformasi data ini dapat berguna untuk berbagai tujuan seperti visualisasi, analisis, atau membuat fitur kategorikal untuk model pembelajaran mesin. Transformasi ini dapat membantu menyederhanakan data dan membuatnya lebih mudah digunakan saat berurusan dengan rentang nilai."""

df_numerik['popularity'].hist(bins = 5)

df_numerik['popularity'].head()

df_numerik.popularity.isna().sum()

def popularity_category(popularity):
  if (popularity >= 0 and popularity <21):
    popularity = 'pop1'
  elif (popularity>= 21 and popularity <41):
    popularity = 'pop2'
  elif (popularity>= 41 and popularity < 61):
    popularity = 'pop3'
  elif (popularity>= 61 and popularity < 81):
    popularity = 'pop4'
  elif (popularity>= 81 and popularity <= 100):
    popularity = 'pop5'
  return popularity

df_numerik['popularity'] = df_numerik['popularity'].apply(popularity_category)

df_numerik['popularity'].value_counts().plot(kind= 'bar')

"""lakukan yang sama pada fitur tempo"""

df_numerik['tempo'].hist()
plt.yscale("log")

def tempo_category(tempo):
  if (tempo >= 0 and tempo <44):
    tempo = 'tempo1'
  elif (tempo>= 44 and tempo <88):
    tempo = 'tempo2'
  elif (tempo>= 88 and tempo < 132):
    tempo = 'tempo3'
  elif (tempo>= 132 and tempo < 176):
    tempo = 'tempo4'
  elif (tempo>= 176 and tempo <= 221):
    tempo = 'tempo5'
  return tempo
df_numerik['tempo'] = df_numerik['tempo'].apply(tempo_category)

df_numerik['tempo'].value_counts().plot(kind = 'bar')

"""membuat duration dari tracks menjadi satuan menit."""

df_numerik['duration_ms'] = df_numerik['duration_ms'].apply(lambda x : round((x/60000), 2))

df_numerik['duration_ms']

df_numerik['duration_ms'].describe().round(2)

df_numerik

df_numerik.columns

df.loc[(df['loudness'].isin(list(range(-15, 0)))),[ 'track_genre', 'track_name', 'artists']]

df_numerik[['danceability', 'energy','loudness']].hist(figsize=(10,10))

df_numerik[['speechiness', 'acousticness', 'instrumentalness',]].hist(figsize=(10,10))

df_numerik[['liveness', 'valence']].hist(figsize=(10,5))

df_numerik[['key','mode', 'time_signature']].hist(figsize=(10,10))

"""## Data Preparation

### Feature engineering

Scaling fitur numerik menggunakan min-max scaler
"""

def scaling(df_numerik):
    numerik = df_numerik.reset_index(drop = True)
    scaler = MinMaxScaler()
    numerik_scaled = pd.DataFrame(scaler.fit_transform(numerik), columns = numerik.columns)
    return numerik_scaled

def one_hot_encoding(df, fitur):
  ohe = pd.get_dummies(df[fitur])
  ohe.reset_index(drop = True, inplace = True)
  return ohe

def create_feature(df_numerik, df_categorical):
  tfidf = TfidfVectorizer(tokenizer=lambda x: x.split(','))
  tfidf_matrix =  tfidf.fit_transform(df_categorical['track_genre'])
  df_genre = pd.DataFrame(tfidf_matrix.toarray())
  df_genre.columns = [f"genre | {i}" for i in tfidf.get_feature_names_out()]
  df_genre.reset_index(drop = True, inplace=True)

  ohe_popularity = one_hot_encoding(df_numerik, 'popularity')
  ohe_tempo = one_hot_encoding(df_numerik, 'tempo')

  df_numerik.pop('popularity')
  df_numerik.pop('tempo')

  numerik_scaled = scaling(df_numerik)
  final_df = pd.concat([df_genre, ohe_popularity, ohe_tempo, numerik_scaled], axis = 1)

  final_df['track_name']=df_categorical['track_name'].values
  return final_df

final_df = create_feature(df_numerik, df_categorical)

final_df

"""## Modelling"""

custom_df = final_df.drop('track_name', axis = 1)

cosine_sim = cosine_similarity(custom_df, custom_df)

cosine_sim_df = pd.DataFrame(cosine_sim, index=final_df['track_name'], columns=final_df['track_name'])

cosine_sim_df.sample(10, axis=1).sample(10, axis=0)

data_rekomendasi = df.copy()

def get_recommendations(track_name, n = 5):
  indices = pd.Series(final_df.index, index=final_df['track_name']).drop_duplicates()
  try:
    idx = indices[track_name]
  except KeyError:
    return "Lagu tidak ditemukan"
  sim_scores = list(enumerate(cosine_sim[idx]))
  sim_scores = sorted(sim_scores, key=lambda x: x[1], reverse=True)
  sim_scores = sim_scores[1:n+1]
  song_indices = [i[0] for i in sim_scores]
  sim_scores_list = [i[1] for i in sim_scores]
  recommended_songs = data_rekomendasi[['track_name', 'artists', 'album_name']].iloc[song_indices]

  recommended_songs['similiarity_score'] = sim_scores_list

  return track_name, recommended_songs

track_name, recommended_songs = get_recommendations("DDU-DU DDU-DU", n=10)
print(f"lagu yang pengguna dengar {track_name}")
recommended_songs

def relevant(cos_sim):
  num_relevant = 0
  for cs in cos_sim:
    if cs > 0.95:
      num_relevant +=1
  return num_relevant

def precision(num_relevant, num_recommend_song):
  precision = num_relevant/ num_recommend_song
  return precision

recommendations = get_recommendations("DDU-DU DDU-DU", n=10)
cosine_similarity_values = recommended_songs['similiarity_score']
number_recommended_song = recommended_songs.shape[0]

num_relevant= relevant(cosine_similarity_values)
precision = precision(num_relevant, number_recommended_song)
print(f"Jumlah lagu yang direkomendasikan: {number_recommended_song}")
print(f"Jumlah rekomendasi relevan: {num_relevant}")
print(f"precision: {precision}")